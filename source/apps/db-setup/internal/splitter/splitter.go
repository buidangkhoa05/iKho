// Package splitter parses db/models.go (generated by sqlc) and splits every
// struct type into its own <lowercase>.go file.
// After splitting, models.go is replaced with either a minimal stub (same
// package) or a type-alias bridge (sub-package).
package splitter

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// Split reads modelsFile, writes one file per struct into outDir (same package
// "db"), rewrites modelsFile as a minimal stub, and returns the created paths.
func Split(modelsFile, outDir string) ([]string, error) {
	return splitInternal(modelsFile, outDir, "db", "")
}

// SplitToSubpackage splits structs into outDir as a separate Go package named
// after the directory base (e.g. "models"). It rewrites modelsFile with
// type aliases so that the parent package (db) keeps all its existing names.
// importPath is the full Go import path used in the alias, e.g.
// "github.com/buidangkhoa05/iKho/apps/db-setup/db/models".
func SplitToSubpackage(modelsFile, outDir, importPath string) ([]string, error) {
	outPkg := filepath.Base(outDir)
	return splitInternal(modelsFile, outDir, outPkg, importPath)
}

func splitInternal(modelsFile, outDir, outPkg, aliasImportPath string) ([]string, error) {
	src, err := os.ReadFile(modelsFile)
	if err != nil {
		return nil, fmt.Errorf("read %s: %w", modelsFile, err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, modelsFile, src, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse %s: %w", modelsFile, err)
	}

	// Collect the sqlc version comment block from the top of the file.
	generatedHeader := extractGeneratedHeader(f)

	// Collect all imports declared in models.go, keyed by their local name.
	allImports := collectImports(f)

	var createdFiles []string
	var structNames []string // track names in declaration order for alias stub

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if _, isStruct := typeSpec.Type.(*ast.StructType); !isStruct {
				continue
			}

			// Determine which imports this struct actually uses.
			needed := importsNeededByStruct(typeSpec, allImports)

			// Render the struct declaration.
			var structBuf bytes.Buffer
			if err := format.Node(&structBuf, fset, &ast.GenDecl{
				Tok:    token.TYPE,
				Specs:  []ast.Spec{typeSpec},
				Lparen: genDecl.Lparen,
				Rparen: genDecl.Rparen,
			}); err != nil {
				return nil, fmt.Errorf("render struct %s: %w", typeSpec.Name.Name, err)
			}

			// Build the output file source.
			var buf bytes.Buffer
			buf.WriteString(generatedHeader)
			buf.WriteString("\n")
			fmt.Fprintf(&buf, "package %s\n", outPkg)
			if len(needed) > 0 {
				buf.WriteString("\nimport (\n")
				for _, imp := range needed {
					buf.WriteString("\t")
					buf.WriteString(imp)
					buf.WriteString("\n")
				}
				buf.WriteString(")\n")
			}
			buf.WriteString("\n")
			buf.Write(structBuf.Bytes())
			buf.WriteString("\n")

			formatted, err := format.Source(buf.Bytes())
			if err != nil {
				return nil, fmt.Errorf("format output for %s: %w\n--- source ---\n%s", typeSpec.Name.Name, err, buf.String())
			}

			outName := strings.ToLower(typeSpec.Name.Name) + ".go"
			outPath := filepath.Join(outDir, outName)
			if err := os.WriteFile(outPath, formatted, 0644); err != nil {
				return nil, fmt.Errorf("write %s: %w", outPath, err)
			}
			createdFiles = append(createdFiles, outPath)
			structNames = append(structNames, typeSpec.Name.Name)
		}
	}

	// Rewrite models.go.
	var stubBuf bytes.Buffer
	stubBuf.WriteString(generatedHeader)
	stubBuf.WriteString("\n")

	if aliasImportPath == "" {
		// Same-package split: minimal stub, no duplicate declarations needed.
		stubBuf.WriteString("package db\n")
	} else {
		// Sub-package split: type-alias bridge so query.sql.go keeps compiling.
		stubBuf.WriteString("package db\n")
		stubBuf.WriteString("\n")
		fmt.Fprintf(&stubBuf, "import %q\n", strings.Trim(aliasImportPath, `"`))
		stubBuf.WriteString("\n")
		for _, name := range structNames {
			fmt.Fprintf(&stubBuf, "type %s = %s.%s\n", name, outPkg, name)
		}
	}

	formatted, err := format.Source(stubBuf.Bytes())
	if err != nil {
		formatted = stubBuf.Bytes() // fall back to unformatted if alias block is unusual
	}
	if err := os.WriteFile(modelsFile, formatted, 0644); err != nil {
		return nil, fmt.Errorf("rewrite %s: %w", modelsFile, err)
	}

	return createdFiles, nil
}

// extractGeneratedHeader returns the "// Code generated by sqlc..." comment
// block as a string (with trailing newline). Falls back to a generic one.
func extractGeneratedHeader(f *ast.File) string {
	for _, cg := range f.Comments {
		for _, c := range cg.List {
			if strings.HasPrefix(c.Text, "// Code generated") {
				var sb strings.Builder
				for _, line := range cg.List {
					sb.WriteString(line.Text)
					sb.WriteString("\n")
				}
				return sb.String()
			}
		}
	}
	return "// Code generated by sqlc. DO NOT EDIT.\n"
}

// collectImports returns a map from short identifier (or last path segment) to
// the quoted import path string, e.g. "pgtype" -> `"github.com/jackc/pgx/v5/pgtype"`.
func collectImports(f *ast.File) map[string]string {
	m := make(map[string]string)
	for _, imp := range f.Imports {
		path := imp.Path.Value
		var localName string
		if imp.Name != nil {
			localName = imp.Name.Name
		} else {
			trimmed := strings.Trim(path, `"`)
			parts := strings.Split(trimmed, "/")
			localName = parts[len(parts)-1]
		}
		m[localName] = path
	}
	return m
}

// importsNeededByStruct inspects every field type of the struct and returns
// the quoted import path strings for packages actually referenced.
func importsNeededByStruct(ts *ast.TypeSpec, allImports map[string]string) []string {
	used := make(map[string]bool)
	st := ts.Type.(*ast.StructType)
	for _, field := range st.Fields.List {
		collectSelectorIdents(field.Type, used)
	}

	var result []string
	for pkg := range used {
		if path, ok := allImports[pkg]; ok {
			result = append(result, path)
		}
	}
	return result
}

// collectSelectorIdents walks an expression and records any X in X.Y
// (i.e. qualified type expressions like pgtype.Text).
func collectSelectorIdents(expr ast.Expr, used map[string]bool) {
	switch t := expr.(type) {
	case *ast.SelectorExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			used[ident.Name] = true
		}
	case *ast.StarExpr:
		collectSelectorIdents(t.X, used)
	case *ast.ArrayType:
		collectSelectorIdents(t.Elt, used)
	case *ast.MapType:
		collectSelectorIdents(t.Key, used)
		collectSelectorIdents(t.Value, used)
	}
}
